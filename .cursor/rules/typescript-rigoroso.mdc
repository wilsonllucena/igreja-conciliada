---
alwaysApply: true
---

# TypeScript Rigoroso - Pr√°ticas Obrigat√≥rias

## Princ√≠pios Fundamentais

### 1. Proibi√ß√£o de @ts-ignore Sem Justificativa
- **NUNCA** use `@ts-ignore` sem uma explica√ß√£o detalhada
- Toda supress√£o de erro TypeScript DEVE ser documentada
- Prefira sempre corrigir o erro ao inv√©s de suprimir

### ‚úÖ Correto:
```typescript
// @ts-ignore: API externa n√£o tipada corretamente, aguardando atualiza√ß√£o v2.3.1
const result = externalLibrary.untypedMethod();

// @ts-ignore: Tipo complexo do TypeORM que gera falso positivo
const query = repository.createQueryBuilder('entity')
```

### ‚ùå Incorreto:
```typescript
// @ts-ignore
const result = someMethod();

// @ts-ignore erro tempor√°rio
const data = getData();
```

## 2. Tratamento de Warnings Como Erros

### Configura√ß√£o Obrigat√≥ria
- Todos os warnings TypeScript devem ser tratados como erros
- Zero toler√¢ncia para warnings n√£o resolvidos
- Configure `"noEmitOnError": true` no tsconfig.json

### Warnings Comuns que Devem Ser Corrigidos
- Vari√°veis n√£o utilizadas (`noUnusedLocals: true`)
- Par√¢metros n√£o utilizados (`noUnusedParameters: true`)
- Imports n√£o utilizados
- Propriedades opcionais mal definidas
- Any impl√≠cito (`noImplicitAny: true`)

## 3. Tipagem Rigorosa Obrigat√≥ria

### Evitar `any` a Todo Custo
```typescript
// ‚ùå Nunca fa√ßa isso
const data: any = getData();

// ‚úÖ Prefira tipagem espec√≠fica
interface ApiResponse {
  id: number;
  name: string;
  status: 'active' | 'inactive';
}
const data: ApiResponse = getData();

// ‚úÖ Se necess√°rio, use unknown e fa√ßa type guards
const data: unknown = getData();
if (isApiResponse(data)) {
  // Agora data √© do tipo ApiResponse
  console.log(data.name);
}
```

### Tipos Expl√≠citos para Fun√ß√µes P√∫blicas
```typescript
// ‚úÖ Correto: tipos expl√≠citos
export function processarCessao(
  dados: CessionDto
): Promise<CessionEntity> {
  return this.cessionService.create(dados);
}

// ‚ùå Incorreto: tipos inferidos para APIs p√∫blicas
export function processarCessao(dados) {
  return this.cessionService.create(dados);
}
```

## 4. Valida√ß√£o de Nullability

### Strict Null Checks Obrigat√≥rio
- Configure `"strictNullChecks": true`
- Sempre trate possibilidades de null/undefined
- Use optional chaining e nullish coalescing

```typescript
// ‚úÖ Correto: tratamento expl√≠cito de null
const usuario = await this.userService.findById(id);
if (!usuario) {
  throw new NotFoundException('Usu√°rio n√£o encontrado');
}
return usuario.nome; // Seguro ap√≥s verifica√ß√£o

// ‚úÖ Correto: usando optional chaining
const nomeCompleto = usuario?.profile?.fullName ?? 'Nome n√£o dispon√≠vel';

// ‚ùå Incorreto: assumindo que nunca ser√° null
const nomeCompleto = usuario.profile.fullName; // Pode quebrar
```

## 5. Interfaces e Tipos Bem Definidos

### Estrutura Obrigat√≥ria
- Todos os objetos complexos devem ter interfaces
- Use union types para valores espec√≠ficos
- Prefira `interface` para objetos, `type` para unions/primitivos

```typescript
// ‚úÖ Correto: interface bem definida
interface CessionRequest {
  fundId: number;
  contractIds: string[];
  requestedAmount: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  metadata?: {
    createdBy: string;
    tags: string[];
  };
}

// ‚ùå Incorreto: objeto sem tipagem
const request = {
  fundId: 123,
  contractIds: ['abc', 'def'],
  // ... sem tipo definido
};
```

## 6. Error Handling Tipado

### Exce√ß√µes Tipadas
```typescript
// ‚úÖ Correto: erros espec√≠ficos e tipados
class CessionProcessingError extends Error {
  constructor(
    message: string,
    public readonly cessionId: string,
    public readonly errorCode: 'VALIDATION_FAILED' | 'EXTERNAL_API_ERROR' | 'TIMEOUT'
  ) {
    super(message);
    this.name = 'CessionProcessingError';
  }
}

// ‚úÖ Uso correto com tipos espec√≠ficos
try {
  await this.processCession(data);
} catch (error) {
  if (error instanceof CessionProcessingError) {
    // Tratamento espec√≠fico
    this.logger.error('Cession processing failed', {
      cessionId: error.cessionId,
      errorCode: error.errorCode
    });
  } else {
    // Re-throw erros n√£o esperados
    throw error;
  }
}
```

## 7. Checklist Pr√©-Commit

### ‚úÖ Verifica√ß√µes Obrigat√≥rias:
1. Zero erros TypeScript (`tsc --noEmit`)
2. Zero warnings TypeScript
3. Todos os `@ts-ignore` est√£o documentados
4. Tipos expl√≠citos em fun√ß√µes p√∫blicas
5. Null checks implementados onde necess√°rio
6. Interfaces definidas para objetos complexos

### üö´ Pr√°ticas Proibidas:
- `@ts-ignore` sem coment√°rio explicativo
- Uso de `any` sem justificativa extrema
- Warnings n√£o resolvidos
- Fun√ß√µes p√∫blicas sem tipagem expl√≠cita
- Assumir que valores nunca s√£o null/undefined

## 8. Configura√ß√£o TypeScript Recomendada

```json
// tsconfig.json - configura√ß√µes obrigat√≥rias
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noEmitOnError": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## 9. Integra√ß√£o com Linter

### ESLint Rules Obrigat√≥rias
```json
{
  "@typescript-eslint/no-explicit-any": "error",
  "@typescript-eslint/ban-ts-comment": "error",
  "@typescript-eslint/no-unused-vars": "error",
  "@typescript-eslint/strict-boolean-expressions": "error"
}
```

---

*Esta regra garante que o c√≥digo TypeScript seja sempre robusto, bem tipado e livre de erros, mantendo alta qualidade e confiabilidade do sistema.*